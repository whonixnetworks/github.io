---
title: Git Guide - Mastering Version Control from the Command Line
description: >
  Learn Git from the ground up using the command line interface. This comprehensive guide covers everything from basic commits to advanced workflows for homelab and development projects.
date: 2025-10-19
categories: [Cheat Sheets]
tags: [git, cli, version-control, development, homelab]
pin: true
---

![Desktop View](/assets/img/post-images/git-guide.png){: width="972" height="589" .w-50 .right}

If you've ever found yourself confused by Git or relying on graphical tools without understanding what's happening underneath, you're not alone.  

Git can seem intimidating at first, but mastering the command line interface gives you complete control and a deeper understanding of how version control really works. 

This guide will take you from absolute beginner to confident Git user, all through the power of the command line

----

## Why Learn Git CLI?

While graphical Git tools are useful, the command line offers:  

> **Universal access**: Available on every system, no matter the OS  
> **Precise control**: Every action is explicit and under your control  
> **Better understanding**: You'll truly grasp how Git works internally  
> **Automation friendly**: Easy to script and integrate with other tools  
> **Remote server skills**: Essential for working with headless servers    
----

### Getting Started: Installation and Setup

**Installing Git**  
>Ubuntu/Debian:

```bash
sudo apt update
sudo apt install git
```

> CentOS/RHEL:

```bash
sudo yum install git
# or for newer versions:
sudo dnf install git
```

> macOS:

```bash
# Using Homebrew:
brew install git
```

> Windows:
>> Download from [Git-Scm](git-scm.com)  

**Essential Configuration**

```bash
# Set your identity (crucial for commits)
git config --global user.name "Your Name"
git config --global user.email "your.email@example.com"

# Set your default editor
git config --global core.editor "nano"  # or vim, code, etc.

# Enable colorful output
git config --global color.ui auto

# Verify your settings
git config --list
```

Your name and email are embedded in every commit you make.  Use an email associated with your GitHub/GitLab account if you want contributions linked to your profile.
{:.prompt-tip }
----

### Core Git Concepts

**The Three States**

Git has three main states where your files can reside:

> 1. **Working Directory:** Where you make changes to files
> 2. **Staging Area:** Where you prepare changes for commit
> 3. **Repository:** Where committed changes are permanently stored

Basic Workflow

```bash
# 1. Make changes to files
nano script.sh

# 2. Stage the changes
git add script.sh

# 3. Commit the changes
git commit -m "Add new deployment script"

# 4. Push to remote (if configured)
git push origin main
```
----

### Essential Git Commands

**Repository Management**

Initialize a new repository:

```bash
git init my-project
cd my-project
```

Clone an existing repository:

```bash
git clone https://github.com/username/repository.git
git clone https://github.com/username/repository.git my-folder-name
```

Check repository status:

```bash
git status
git status -s  # Short format
```

**Making Changes**

Stage files for commit:

```bash
git add filename.txt           # Stage specific file
git add folder/               # Stage entire folder
git add .                     # Stage all changes
git add -p                    # Stage changes interactively
```

Commit your changes:

```bash
git commit -m "Descriptive commit message"
git commit -am "Add message and commit all tracked files"
```

Write good commit messages:

```bash
# Good commit message structure:
git commit -m "feat: add automated backup script

> Add daily backup script for Docker volumes
> Include configuration for retention policy
> Add error handling and logging
> Update documentation with setup instructions"
```

Use conventional commit prefixes like `feat:`, `fix:`, `docs:`, `style:`, `refactor:`, `test:`, `chore:` to make your commit history more readable.
{:.prompt-info }
----

### Viewing History and Changes

View commit history:

```bash
git log
git log --oneline           # Compact view
git log --graph --oneline   # Visual branch history
git log -p                  # Show changes in each commit
git log --since="2024-01-01"
```

See what changed:

```bash
git diff                    # Unstaged changes
git diff --staged           # Staged changes
git diff HEAD~1             # Compare with previous commit
git show commit_hash        # Show specific commit
```
----

### Branching and Merging

**Understanding Branches**

Branches let you work on multiple features simultaneously without affecting the main codebase.

```bash
# View branches
git branch                  # Local branches
git branch -r              # Remote branches  
git branch -a              # All branches

# Create and switch to new branch
git branch new-feature
git checkout new-feature
# Or combine both:
git checkout -b new-feature

# Switch between branches
git checkout main
git checkout development

# Delete branches
git branch -d old-branch    # Safe delete (checks merge status)
git branch -D old-branch    # Force delete
```

**Merging and Rebasing**

Merge branches:

```bash
# Switch to target branch first
git checkout main

# Merge feature branch
git merge feature-branch

# For complex merges, use no-fast-forward:
git merge --no-ff feature-branch
```

**Rebase instead of merge:**

```bash
# Rebase current branch onto main
git checkout feature-branch
git rebase main

# Interactive rebase (great for cleaning up history)
git rebase -i HEAD~3  # Rebase last 3 commits
```

Use merging for public branches and rebasing for private feature branches. Rebasing rewrites history, which can cause issues for collaborators.
{:.prompt-warning }
----

### Working with Remote Repositories

**Connecting to Remotes**

Add remote repositories:

```bash
git remote add origin https://github.com/username/repo.git
git remote -v  # View configured remotes
```

Push to remote:

```bash
git push -u origin main          # First push, set upstream
git push                         # Subsequent pushes
git push origin feature-branch   # Push specific branch
```

Pull from remote:

```bash
git pull                        # Fetch and merge
git pull --rebase               # Fetch and rebase
git fetch                       # Fetch without merging
```

**Common Remote Operations**

```bash
# See differences between local and remote
git fetch
git log origin/main..main    # What's locally that's not remote
git log main..origin/main    # What's remote that's not local

# Push with tags
git push --tags

# Delete remote branch
git push origin --delete old-branch
```
----

### Advanced Git Features

Stashing Changes

```bash
# Save uncommitted changes temporarily
git stash
git stash push -m "Work in progress on feature"

# List stashes
git stash list

# Apply stashed changes
git stash apply          # Apply latest stash
git stash apply stash@{1} # Apply specific stash

# Create branch from stash
git stash branch new-branch-name

# Clear stashes
git stash clear
```

Tagging Releases

```bash
# Create lightweight tag
git tag v1.0.0

# Create annotated tag (recommended)
git tag -a v1.0.1 -m "Release version 1.0.1"

# Push tags to remote
git push --tags
git push origin v1.0.1

# List tags
git tag
git tag -l "v1.0*"      # Filter tags
```

Undoing Changes

**Safe undos (history preserved):**

```bash
# Revert a commit (creates new commit that undoes changes)
git revert commit_hash

# Reset staging area (keep changes in working directory)
git reset

# Reset to specific commit (keep changes)
git reset commit_hash
```

**Dangerous undos (history modified):**

```bash
# Hard reset - DESTROYS CHANGES
git reset --hard commit_hash
git reset --hard origin/main  # Match remote exactly

# Amend last commit
git commit --amend
```

Be extremely careful with git reset --hard as it permanently destroys uncommitted changes. Always double-check with git status and git diff first.
{:.prompt-danger }
----

### Git in Homelab Workflows

Configuration Management

```bash
# Track your homelab configuration
git init homelab-config
cd homelab-config

# Add important files
git add docker-compose.yml
git add nginx/ traefik/ scripts/
git commit -m "feat: initial homelab configuration"

# Push to private GitHub/GitLab repository
git remote add origin https://github.com/username/homelab-config.git
git push -u origin main
```

Script Management

```bash
# Example: Managing deployment scripts
git add scripts/deploy.sh
git commit -m "feat: add automated deployment script"

# Update script later
nano scripts/deploy.sh
git add scripts/deploy.sh
git commit -m "fix: resolve path issue in deploy script"

# View change history
git log --oneline scripts/deploy.sh
```

Docker Compose Versioning

```bash
# Track docker-compose changes
git add docker-compose.yml
git commit -m "feat: add jellyfin media server"

# Make changes
nano docker-compose.yml
git add docker-compose.yml
git commit -m "feat: add traefik reverse proxy"

# Revert if something breaks
git log --oneline docker-compose.yml
git checkout commit_hash -- docker-compose.yml
```
----

### Troubleshooting Common Issues

Merge Conflicts

```bash
# When you encounter a conflict:
git status  # Shows conflicted files

# Edit the files to resolve conflicts
# Look for <<<<<<<, =======, >>>>>>> markers
nano conflicted-file.txt

# After resolving:
git add conflicted-file.txt
git commit  # Complete the merge
```

Detached HEAD State

```bash
# If you see this warning:
# "You are in 'detached HEAD' state..."

# Create a new branch to preserve changes
git branch new-branch-name
git checkout new-branch-name

# Or go back to previous branch
git checkout -
```

Authentication Issues

```bash
# For HTTPS remotes, cache credentials
git config --global credential.helper cache

# For SSH, ensure your key is added
ssh-add ~/.ssh/id_rsa

# Test SSH connection to GitHub
ssh -T git@github.com
```
----

### Git Aliases

Save time with these aliases:

```bash
# Add to ~/.gitconfig
[alias]
    co = checkout
    br = branch
    ci = commit
    st = status
    unstage = reset HEAD --
    last = log -1 HEAD
    lol = log --graph --oneline --decorate
    lola = log --graph --oneline --decorate --all
    hist = log --pretty=format:\"%h %ad | %s%d [%an]\" --graph --date=short
    type = cat-file -t
    dump = cat-file -p
```
----

### Best Practices for Homelab Use

**Commit Often, Perfect Later**

```bash
# Make small, frequent commits
git add .
git commit -m "wip: work in progress"

# Clean up later with interactive rebase
git rebase -i HEAD~5
```

Meaningful Commit Messages

```bash
# Good:
git commit -m "feat: add automated backup system"

# Avoid:
git commit -m "fixed stuff"
```

Branch Strategy

```bash
# Main branches
main          # Stable production
develop       # Integration branch

# Feature branches
feature/add-monitoring
feature/update-docker-setup
fix/nginx-config
```

Backup Your Repository

```bash
# Regular pushes to remote serve as backup
git push origin main

# Or create bundles for offline backup
git bundle create backup.bundle --all
```
----

### Integrating Git with Other Tools

Git Hooks for Automation

```bash
# Example pre-commit hook (.git/hooks/pre-commit)
#!/bin/bash
# Prevent committing to main directly
branch=$(git symbolic-ref --short HEAD)
if [ "$branch" = "main" ]; then
    echo "Direct commits to main are not allowed."
    exit 1
fi
```

CI/CD Integration

```bash
# Example GitHub Actions trigger
# .github/workflows/deploy.yml
name: Deploy to Homelab
on:
  push:
    branches: [ main ]
```
----

### Learning Resources

> Pro Git Book: Free online at git-scm.com/book
> GitHub Learning Lab: Interactive Git tutorials
> Oh My Git!: Game for learning Git concepts
> GitKatas: Practice exercises for Git skills

### Final Thoughts

Mastering Git CLI might seem daunting at first, but it's one of the most **valuable** skills you can develop for homelab **management** and software development.  
The command line gives you a deep understanding of what's actually happening with your **version control**, making you more effective and confident.  

Start with the basics, practice regularly, and don't be afraid to **experiment** in a test repository.  
The time investment will pay off many times over in saved frustration and increased productivity.

Remember: Git is a tool, not a magic solution. The real power comes from using it consistently and understanding how it works. Take it one command at a time, and soon you'll be wondering how you ever managed without it.
{:.prompt-tip }
